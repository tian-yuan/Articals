### C11 新特性

#### auto 自动类型推导

* 简化编程
* 是否影响编译速度？
* 模板参数上可以得到简化

```
template <typename Product, typename Creator>
void processProduct(const Creator& creator) {
    Product* val = creator.makeObject();
    // do somthing with val
}		
	
template <typename Creator>
void processProduct(const Creator& creator) {
    auto val = creator.makeObject();
    // do somthing with val
}	
```



#### decltype

decltype实际上有点像auto的反函数，auto可以让你声明一个变量，而decltype则可以从一个变量或表达式中得到类型，有实例如下：

```
int x = 3;
decltype(x) y = x;
```

decltype 用处是什么？有了 auto 就需要 decltype？

#### nullptr

nullptr是为了解决原来C++中NULL的二义性问题而引进的一种**新的类型**，因为NULL实际上代表的是0

```
const class nullptr_t
{
public:
    template<class T>
    inline operator T*() const
        { return 0; }

    template<class C, class T>
    inline operator T C::*() const
        { return 0; }
 
private:
    void operator&() const;
} nullptr = {};
```

nullptr 是一个对象

#### Lambda 表达式

lambda表达式类似Javascript中的闭包，它可以用于创建并定义匿名的函数对象，以简化编程工作

```
vector<int> iv{5, 4, 3, 2, 1};
int a = 2, b = 1;

for_each(iv.begin(), iv.end(), [b](int &x){cout<<(x + b)<<endl;}); // (1)

for_each(iv.begin(), iv.end(), [=](int &x){x *= (a + b);});		// (2)

for_each(iv.begin(), iv.end(), [=](int &x)->int{return x * (a + b);});// (3)
```

#### 变长参数的模板



```
template<typename head, typename... tail>
void Print(Head head, typename... tail) {
	cout<< head <<endl;
	Print(tail...);
}
这个使用了递归打印
```

#### 左值和右值

https://www.ibm.com/developerworks/cn/aix/library/1307_lisl_c11/

#### 完美转发

#### 完美转发(std::forward)

程序员在不写高度泛型代码的时候，完美转发的好处可能还体会不到，在C++98/0x时代，当我们需要写泛型代码的时候，可能会遇到函数调用的一些问题。

```
void __Test(int &t)
{
}

template<typename T>
void Test(const T &t)
{
  // do other things... 
  __Test(t);
}

int i = 0;
Test(i);

```

上述的代码将会无法通过编译，究其原因，t在进入Test之后为const T&，而调用__Test之后是T&，模板无法从const T&推导为T&。针对这个问题，我们有两种方法解决：

```
template<typename T>
void Test(const T& t)
{
  // do other things...
  __Test(const_cast<T&>(t));
}

```

经过修改后，Test可以编译通过。我们通过const_cast去掉了const属性，仔细想想，用const_cast合适吗？显然这里用const_cast破坏了函数的健壮性。有没有其他的方法解决呢？我们特化模板表以适当的类型或重载调用函数解决这个问题：

```
void __Test(const int &t)
{}

// or
void __Test(int & t)
{}
// or
template<typename T>
void Test(T &t)
{}

// or
template<typename T>
void Test(T &t)
{}

```

这样问题顺利解决，无论是我们调用Test(i)还是Test(5)都可以顺利通过编译。

现实世界里的代码不会这么简单，上面的测试代码只涉及到了一个参数，假如某一模板函数有两个参数遇到这种情况之后怎么办？C++0x/98下我们可能会写出这样的代码：

```
template<typename T>
void Test(T &t1, T &t2)
{
  __Test(t1, t2);
}
template<typename T>
void Test(const T &t1, const T &t2)
{
  __Test(t1, t2);
}
template<typename T>
void Test(const T &t1, T &t2)
{
  __Test(t1, t2);
}
template<typename T>
void Test(T &t1, const T &t2)
{
  __Test(t1, t2);
}

```

当我写完这一段示例代码，我的第一感觉是：这简直就是一段毫无技术含量的活，程序员万万不能将时间浪费在这一段代码上面。当我们有两个参数的模板函数会有4个特化.问题不在这里，因为参数类型不同，Test最终将参数转发到__Test中了，意味着什么？意味着我们还要为__Test重载不同参数类型的版本。两个参数能重载出4个，如果有三个参数，四个参数甚至五个参数的时候，__Test究竟需要多少个重载函数才能满足？这样就是为什么VC9的std::bind里面5个参数就重载了63个函数，多么庞大的数量，而这些全是靠人力堆积起来的。

要么将模板函数Test数量减少，要么将被转发函数__Test数量减少，程序员应该将大脑和手用在需要的地方。

现在我们有了左值和右值得概念，这种问题有比较好的解决手段。

```
template<typename T>
struct RemoveReference
{
  typedef T Type;
};

template<typename T>
struct RemoveReference<T&>
{
  typedef T Type;
};

template<typename T>
struct RemoveReference<T&&>
{
  typedef T Type;
};

template<typename T>
T&& ForwardValue(typename RemoveReference<T>::Type&& value)
{
  return (T&&)value;
}

template<typename T>
T&& ForwardValue(typename RemoveReference<T>::Type& value)
{
  return (T&&)value;
}

```

有了上面的代码之后（实际上也就是std::forward的大致实现），然后我们的代码就简单多了：

```
template<typename T>
void Test(T &&t1, T &&t2)
{
  __Test(ForwardValue<T>(t1), ForwardValue<T>(t2));
}

```

无论我们的__Test接受什么形式的参数，即使有多个形式的__Test，都可以调用到正确的__Test中，从而不再需要特化多个模板函数，这就是完美转发。

所谓完美转发：无论目的调用函数需要哪种类型的参数都可以正确调用到我们想要的那个函数里。上main的示例代码中出现了&&，暂且我们把&&这个叫做右值引用吧。C++11中实现完美转发是依靠的类型推导和引用折叠。类型推导不用多说，STL中的容器广泛使用了类型推导，那引用折叠式什么？

引用折叠规则就是函数接受参数形式与传入参数形式之间进行引用简化，具体编译器定义了这样一条规则：

```
1. T& + & => T&
2. T&& + & => T&
3. T& + && => T&
4. T&& + && => T&&

```

上面的规则中，前者代表接受类型，后者代表进入类型，=>表示引用折叠之后的类型，即最后被推导决断的类型。

现在我们用一段实例代码来看看引用折叠是怎么运作的。

```
template <typename T> 
struct Name;

template <> 
struct Name<string> 
{
  static const char * get() 
  {
    return "string";
  }
};

template <> 
struct Name<const string> 
{
  static const char * get() 
  {
    return "const string";
  }
};

template <> 
struct Name<string&> 
{
  static const char * get() 
  {
    return "string&";
  }
};

template <> 
struct Name<const string&> 
{
  static const char * get() 
  {
    return "const string&";
  }
};

template <> 
struct Name<string&&> 
{
  static const char * get() 
  {
    return "string&&";
  }
};

template <> 
struct Name<const string&&> 
{
  static const char * get()
  {
    return "const string&&";
  }
};

template <typename T> 
void quark(T&& t) 
{
  cout << "**********************************" << endl;
  cout << "t: " << t << endl;
  cout << "T: " << Name<T>::get() << endl;  // -->A
  cout << "T&&: " << Name<T&&>::get() << endl;  // -->B
  cout << endl;
}

string strange() 
{
  return "strange()";
}

const string charm() 
{
  return "charm()";
}


int main()
{
  string up("up");
  const string down("down");
  
  quark(up);	// -->1
  quark(down);	// -->2
  quark(strange());	// -->3
  quark(charm());		// -->4
  
  return 0;
}

```

从上面的实例代码大致可以知晓引用折叠的运作。上述代码运行结果：

```
**********************************
t: up
T: string&
T&&: string&

**********************************
t: down
T: const string&
T&&: const string&

**********************************
t: strange()
T: string
T&&: string&&

**********************************
t: charm()
T: const string
T&&: const string&&

```

1. 在调用quack时，up被推导为string&类型。在quack中，T会被推导为string&类型，根据 T& + && -> T&规则，也就是说进入到quack中，T是string&，所以A调用了string&的版本。仍然是上述规则，在执行B时，T依旧被转换和推导为string&，所以就走到了相应的版本中。
2. 因为down具有const属性，所以表现形式与1一样，唯一的区别是A和B均调用到具有const属性的版本。
3. 这里有点特殊，因为strange()返回的是临时对象，类型为string，因此进入quack之后，T仍旧为string类型，因此A最终会进入string的调用版本，同理T&&就是string&&，会进入对应的版本中。
4. 这里有点特殊，因为charm()返回的是临时对象，类型为string，因此进入quack之后，T为string类型，由于有const属性，所以A和B都会调用到const属性的版本。

上面的代码中我们给出了std::forward的大致实现，其实说白了，就是利用引用折叠规则保留参数原始类型，拒绝编译器的类型推导，以达到将参数完美转发到目的函数中。

之所有存在完美转发，其问题实质是：模板参数类型推导在转发过程中无法保证左右值的引用问题。而完美转发就是在不破坏const属性的前提下通过增加左右值引用概念和新增参数推导规则解决这个问题。

##### std::forward的关键字：解决

在模板内，如果我们需要将一组参数原封不动的传递给另外一个参数，在没有完美转发的情况下，考虑参数会有多种类型的重载，因此在没有完美转发的情况下，重载函数个数将会达到2^n个，多么庞大的人工量。当使用std::forward辅以模板参数推导规则以保持参数属性不变，实现完美转发节省了大量的工作。

**注：**以上代码均在VS2015 + Win10上测试。