#### 求矩阵最小路径和



```
// 计算矩阵路径最小和，只允许向右和向下行走
// 使用动态规划来处理

#include <stdlib.h>
#include <vector>
#include <iostream>
#include <algorithm>

void show(int** input, int m, int n) {
    for (int i = 0; i < m; ++i) {
        for (int j = 0; j < n; ++j) {
            std::cout << input[i][j] << " ";
        }
        std::cout << std::endl;
    }
}

int pathDp(int** input, int** output, int m, int n) {
    output[0][0] = input[0][0];
    for (int i = 1; i < m; ++i) {
        output[i][0] = output[i - 1][0] + input[i][0];
    }
    for (int j = 1; j < n; ++j) {
        output[0][j] = output[0][j - 1] + input[0][j];
    }
    for (int i = 1; i < m; ++i) {
        for (int j = 1; j < n; ++j) {
            output[i][j] = (output[i][j - 1] > output[i - 1][j] ? output[i - 1][j] : output[i][j - 1]) + input[i][j];
        }
    }
    show(output, m, n);
    return output[m - 1][n - 1];
}

int** initMatrix(int m, int n) {
    int** ma = new int*[m];
    for (int i = 0; i < m; ++i) {
        ma[i] = new int[n];
    }
    return ma;
}

int main() {
    int m = 4;
    int n = 4;
    int ma[4][4] = {{1, 3, 5, 9}, {8, 1, 3, 4}, {5, 0, 6, 1}, {8, 8, 4, 0}};
    int** input = initMatrix(m, n);
    int** output = initMatrix(m, n);
    for (int i = 0; i < m; ++i) {
        for (int j = 0; j < n; ++j) {
            input[i][j] = ma[i][j];
            output[i][j] = 0;
        }
    }
    int minPath = pathDp(input, output, m, n);
    std::cout << "min path : " << minPath << std::endl;
    return 0;
}

```

